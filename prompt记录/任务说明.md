# Step1

请帮我编写ts脚本，使用prisma，将 decryption_en_micro_msg.sqlite 中的微信聊天记录转化为txt，要求如下

1.  每个会话为一个txt文件
2.  每个txt文件的文件名格式为：
    -  如果是个人聊天记录，文件名格式为：`微信昵称-微信uid.txt`
    -  如果是群聊记录，文件名格式为：`群聊名称-群聊id.txt`
3.  每个txt文件的内容为：
    -  每个聊天记录为一行，允许换行
    -  聊天记录的格式为：`发送时间 发送人昵称/群聊中的名称 聊天内容`
    -  发送时间的格式为：`yyyy-MM-dd HH:mm:ss`
    -  聊天内容的格式为：
        -  如果是文本消息，格式为：`聊天内容`
        -  如果是图片消息，格式为：`[图片]`
        -  如果是语音消息，格式为：`[语音]`
        -  如果是视频消息，格式为：`[视频]`
        -  如果是大表情消息，格式为：`[大表情]`
        -  如果是分享卡片信息，格式为：`[分享卡片]`
        -  如果是撤回消息提醒，格式为：`[撤回消息提醒]`
        -  如果是微信红包，格式为：`[微信红包]`

# 微信数据库表结构

1.  数据库固定位于项目根目录的 `decryption_en_micro_msg.sqlite` 文件
2.  数据库结构如下：
- userinfo 表：存储个人信息，其中 id 为 2 的 value 是个人的微信 id。
- message 表：存储所有的聊天记录。
- chatroom 表：存储所有群聊信息。
- img_flag 表：存储所有用户的在线头像的信息。如果本地 avatar 文件夹没有头像时，可以用这个表的地址来访问用户的头像，其中 reserved2 是缩略图，reserved1 是高清图。
- rcontact 表：存放所有的好友信息。

# 消息内容解析
在 message 表中，type 字段表示着当前消息的类型，一般有如下类型：

- 1：文本消息
- 3：图片消息
- 34：语音消息
- 43：视频消息
- 47：大表情消息
- 49：分享卡片信息
- 1000：撤回消息提醒
- 436207665：微信红包
- 419430449：微信转账
- 1090519089：文件消息 上面的一些媒体类型的消息，例如图片、语音、视频等，都会可以用 msgId 字段去 WxFileIndex.db 数据库中的 WxFileIndex2 表中查找到对应的文件路径。 除了通过去 WxFileIndex2 表查询媒体文件的路径，还可以通过某些字段的拼接和加密直接获取媒体文件的路径。

可以参考这些代码，确定数据含义
```python
# 文件名: wechat/parser.py
# -*- coding: UTF-8 -*-

import sqlite3
from collections import defaultdict, Counter
import itertools
from datetime import datetime
import logging
logger = logging.getLogger(__name__)

from .msg import WeChatMsg, TYPE_SYSTEM

""" tables in concern:
emojiinfo
imginfo2
addr_upload2
chatroom
message
rcontact
img_flag
"""

class WeChatDBParser(object):
    FIELDS = ["msgSvrId","type","isSend","createTime","talker","content","imgPath"]

    def __init__(self, db_fname):
        """ db_fname: a decrypted EnMicroMsg.db"""
        self.db_fname = db_fname
        self.db_conn = sqlite3.connect(self.db_fname)
        self.db_conn_bytes = sqlite3.connect(self.db_fname)
        # https://stackoverflow.com/questions/22751363/sqlite3-operationalerror-could-not-decode-to-utf-8-column
        self.db_conn_bytes.text_factory = lambda b: b
        self.cc = self.db_conn.cursor()

        self.contacts = {}      # username -> nickname
        self.contacts_rev = defaultdict(list)
        self.msgs_by_chat = defaultdict(list)
        self.emoji_groups = {}
        self.emoji_info = {}
        self.emoji_encryption_key = None
        self.avatar_urls = {}
        self._parse()

    def _parse_contact(self):
        contacts = self.cc.execute(
"""
SELECT username,conRemark,nickname FROM rcontact
""")
        for row in contacts:
            username, remark, nickname = row
            if remark:
                self.contacts[username] = remark
            else:
                self.contacts[username] = nickname

        for k, v in self.contacts.items():
            self.contacts_rev[v].append(k)
        logger.info("Found {} names in `contact` table.".format(len(self.contacts)))

    def _parse_msg(self):
        msgs_tot_cnt = 0
        db_msgs = self.db_conn_bytes.cursor().execute(
"""
SELECT {} FROM message
""".format(','.join(WeChatDBParser.FIELDS)))
        unknown_type_cnt = Counter()
        for row in db_msgs:
            values = self._parse_msg_row(row)
            if not values:
                continue
            msg = WeChatMsg(values)
            # TODO keep system message?
            if not WeChatMsg.filter_type(msg.type):
                self.msgs_by_chat[msg.chat].append(msg)
            if not msg.known_type:
                unknown_type_cnt[msg.type] += 1
        logger.warning("[Parser] Unhandled messages (type->cnt): {}".format(unknown_type_cnt))

        for k, v in self.msgs_by_chat.items():
            self.msgs_by_chat[k] = sorted(v, key=lambda x: x.createTime)
            msgs_tot_cnt += len(v)
        logger.info("Found {} message records.".format(msgs_tot_cnt))

    def _parse_userinfo(self):
        userinfo_q = self.cc.execute(""" SELECT id, value FROM userinfo """)
        userinfo = dict(userinfo_q)
        self.username = userinfo.get(2, None)
        if self.username is None:
            nickname = userinfo.get(4, None)
            if nickname is not None:
                self.username = self.contacts_rev.get(nickname, [None])[0]
        if self.username is None:
            logger.error("Cannot find username in userinfo table!")
            self.username = input("Please enter your username:")
        assert isinstance(self.username, str), self.username
        logger.info("Your username is: {}".format(self.username))

    def _parse_imginfo(self):
        imginfo_q = self.cc.execute("""SELECT msgSvrId, bigImgPath FROM ImgInfo2""")
        self.imginfo = {k: v for (k, v) in imginfo_q
                             if not v.startswith('SERVERID://')}
        logger.info("Found {} hd image records.".format(len(self.imginfo)))

    def _find_msg_by_type(self, msgs=None):
        ret = []
        if msgs is None:
            msgs = itertools.chain.from_iterable(self.msgs_by_chat.itervalues())
        for msg in msgs:
            if msg.type == 34:
                ret.append(msg)
        return sorted(ret)

    def _parse_emoji(self):
        # wechat provided emojis
        query = self.cc.execute(
""" SELECT md5, groupid FROM EmojiInfoDesc """)
        for row in query:
            md5, group = row
            self.emoji_groups[md5] = group

        try:
            query = self.cc.execute(
    """ SELECT md5, catalog, name, cdnUrl, encrypturl, aeskey FROM EmojiInfo""")
        except: # old database does not have cdnurl
            pass
        else:
            for row in query:
                md5, catalog, name, cdnUrl, encrypturl, aeskey = row
                if cdnUrl or encrypturl:
                    self.emoji_info[md5] = (catalog, cdnUrl, encrypturl, aeskey)

    def _parse_img_flag(self):
        """Parse the img_flag table which stores avatar for each id."""
        query = self.cc.execute(
""" SELECT username, reserved1 FROM img_flag """)
        for row in query:
            username, url = row
            if url:
                self.avatar_urls[username] = url

    def _parse(self):
        self._parse_contact()
        self._parse_userinfo()  # depend on self.contacts
        self._parse_msg()
        self._parse_imginfo()
        self._parse_emoji()
        self._parse_img_flag()

    def get_emoji_encryption_key(self):
        # obtain local encryption key in a special entry in the database
        # this also equals to md5(imei)
        query = self.cc.execute("SELECT md5 FROM EmojiInfo where catalog == 153")
        results = list(query)
        if len(results):
            assert len(results) == 1, "Found > 1 encryption keys in EmojiInfo. This is a bug!"
            return results[0][0]
        return None

    # process the values in a row
    def _parse_msg_row(self, row):
        """Parse a record of message into my format.

        Note that message are read in binary format.
        """
        values = dict(zip(WeChatDBParser.FIELDS, row))
        values['createTime'] = datetime.fromtimestamp(values['createTime']/ 1000)
        if values['content']:
            try:
                values['content'] = values['content'].decode()
            except:
                logger.warning(f"Invalid byte sequence in message content (type={values['type']}, createTime={values['createTime']})")
                values['content'] = 'FAILED TO DECODE'
        else:
            values['content'] = ''

        values['talker'] = values['talker'].decode()
        if values['imgPath']:
            values['imgPath'] = values['imgPath'].decode()
        values['chat'] = values['talker']
        try:
            if values['chat'].endswith('@chatroom'):
                values['chat_nickname'] = self.contacts[values['chat']]
                content = values['content']

                if values['isSend'] == 1:
                    values['talker'] = self.username
                elif values['type'] == TYPE_SYSTEM:
                    values['talker'] = 'SYSTEM'
                else:
                    talker = content[:content.find(':')]
                    values['talker'] = talker
                    values['talker_nickname'] = self.contacts.get(talker, talker)

                values['content'] = content[content.find('\n') + 1:]
            else:
                tk_id = values['talker']
                values['chat'] = tk_id
                values['chat_nickname'] = self.contacts[tk_id]
                values['talker'] = tk_id
                values['talker_nickname'] = self.contacts[tk_id]
        except KeyError:
            # It's possible that messages are kept in database after contacts been deleted
            logger.warn("Unknown contact: {}".format(values.get('talker', '')))
            return None
        return values

    @property
    def all_chat_ids(self):
        return self.msgs_by_chat.keys()

    @property
    def all_chat_nicknames(self):
        return [self.contacts[k] for k in self.all_chat_ids if len(self.contacts[k])]

    def get_id_by_nickname(self, nickname):
        """
        Get chat id by nickname.
        """
        l = self.contacts_rev[nickname]
        if len(l) == 0:
            raise KeyError("No contacts have nickname {}".format(nickname))
        if len(l) > 1:
            logger.warn("More than one contacts have nickname {}! Using the first contact".format(nickname))
        return l[0]

    def get_chat_id(self, nick_name_or_id):
        """
        Get the unique chat id by either chat id itself, or the nickname of the chat.
        """
        if nick_name_or_id in self.contacts:
            return nick_name_or_id
        else:
            return self.get_id_by_nickname(nick_name_or_id)

```

```python
# 文件名: wechat/msg.py
# -*- coding: UTF-8 -*-
TYPE_MSG = 1
TYPE_IMG = 3
TYPE_SPEAK = 34
TYPE_NAMECARD = 42
TYPE_VIDEO_FILE = 43
TYPE_EMOJI = 47
TYPE_LOCATION = 48
TYPE_LINK = 49  # link share OR file from web, see https://github.com/ppwwyyxx/wechat-dump/issues/52
TYPE_VOIP = 50
TYPE_WX_VIDEO = 62  # video took by wechat
TYPE_SYSTEM = 10000
TYPE_CUSTOM_EMOJI = 1048625
TYPE_REDENVELOPE = 436207665
TYPE_MONEY_TRANSFER = 419430449  # 微信转账
TYPE_LOCATION_SHARING = -1879048186
TYPE_REPLY = 822083633  # 回复的消息.
TYPE_FILE = 1090519089
TYPE_QQMUSIC = 1040187441
TYPE_APP_MSG = 16777265

_KNOWN_TYPES = tuple([eval(k) for k in dir() if k.startswith('TYPE_')])

import re
import json
import io
import html
from pyquery import PyQuery
import xml.etree.ElementTree as ET
import logging
logger = logging.getLogger(__name__)


class WeChatMsg(object):

    @staticmethod
    def filter_type(tp):
        if tp in [TYPE_SYSTEM]:
            return True
        return False

    def __init__(self, values):
        for k, v in values.items():
            setattr(self, k, v)
        self.known_type = self.type in _KNOWN_TYPES

    def msg_str(self):
        if self.type == TYPE_LOCATION:
            try:
                pq = PyQuery(self.content_xml_ready, parser='xml')
                loc = pq('location').attr
                label = loc['label']
                poiname = loc['poiname']
                if poiname:
                    label = poiname
                return "LOCATION:" + label + " ({},{})".format(loc['x'], loc['y'])
            except:
                return "LOCATION: unknown"
        elif self.type == TYPE_LINK:
            pq = PyQuery(self.content_xml_ready)
            url = pq('url').text()
            if not url:
                # TODO: see https://github.com/ppwwyyxx/wechat-dump/issues/52 for
                # more logic to implement
                title = pq('title').text()
                if title:  # may not be correct
                    return "FILE:{}".format(title)
                return "NOT IMPLEMENTED: " + self.content_xml_ready
            return "URL:{}".format(url)
        elif self.type == TYPE_NAMECARD:
            pq = PyQuery(self.content_xml_ready, parser='xml')
            msg = pq('msg').attr
            name = msg['nickname']
            if not name:
                name = msg['alias']
            if not name:
                name = ""
            return "NAMECARD: {}".format(self.content_xml_ready)
        elif self.type == TYPE_APP_MSG:
            pq = PyQuery(self.content_xml_ready, parser='xml')
            return pq('title').text()
        elif self.type == TYPE_VIDEO_FILE:
            return "VIDEO FILE"
        elif self.type == TYPE_WX_VIDEO:
            return "WeChat VIDEO"
        elif self.type == TYPE_VOIP:
            return "REQUEST VIDEO CHAT"
        elif self.type == TYPE_LOCATION_SHARING:
            return "LOCATION SHARING"
        elif self.type == TYPE_EMOJI:
            # TODO add emoji name
            return self.content
        elif self.type == TYPE_REDENVELOPE:
            data_to_parse = io.BytesIO(self.content.encode('utf-8'))
            try:
                for event, elem in ET.iterparse(data_to_parse, events=('end',)):
                    if elem.tag == 'sendertitle':
                        title = elem.text
                        return "[RED ENVELOPE]\n{}".format(title)
            except:
                pass
            return "[RED ENVELOPE]"
        elif self.type == TYPE_MONEY_TRANSFER:
            data_to_parse = io.BytesIO(self.content.encode('utf-8'))
            try:
                for event, elem in ET.iterparse(data_to_parse, events=('end',)):
                    if elem.tag == 'des':
                        title = elem.text
                        return "[Money Transfer]\n{}".format(title)
            except:
                pass
            return "[Money Transfer]"
        elif self.type == TYPE_REPLY:
            pq = PyQuery(self.content_xml_ready)
            titles = pq('title')
            if len(titles) == 0:
                return self.content_xml_ready
            msg = titles[0].text
            # TODO parse reply.
            return msg
        elif self.type == TYPE_FILE:
            pq = PyQuery(self.content_xml_ready)
            titles = pq('title')
            if len(titles) == 0:
                return self.content_xml_ready
            return "FILE:" + titles[0].text
        elif self.type == TYPE_QQMUSIC:
            pq = PyQuery(self.content_xml_ready)
            title = pq('title')[0].text
            singer = pq('des')[0].text
            url = html.unescape(pq('url')[0].text)
            return json.dumps(dict(
                title=title, singer=singer, url=url
            ))
        else:
            # TODO replace smiley with text
            return self.content

    @property
    def content_xml_ready(self):
        # remove xml headers to avoid possible errors it may create
        header = re.compile(r'<\?.*\?>')
        msg = header.sub("", self.content)
        return msg

    def __repr__(self):
        ret = "{}|{}:{}:{}".format(
            self.type,
            self.talker_nickname if not self.isSend else 'me',
            self.createTime,
            self.msg_str())
        if self.imgPath:
            ret = "{}|img:{}".format(ret.strip(), self.imgPath)
            return ret
        else:
            return ret

    def __eq__(self, r):
        return self.createTime == r.createTime and \
                self.talker == r.talker and \
                self.isSend == r.isSend
        # imgPath might change after migration.

    def __lt__(self, r):
        return self.createTime < r.createTime

    def is_chatroom(self):
        return self.talker != self.chat

    def get_chatroom(self):
        if self.is_chatroom():
            return self.chat
        else:
            return ''

    def get_emoji_product_id(self):
        assert self.type == TYPE_EMOJI, "Wrong call to get_emoji_product_id()!"
        pq = PyQuery(self.content_xml_ready, parser='xml')
        emoji = pq('emoji')
        if not emoji:
            return None
        return emoji.attrs['productid']
```

```python
# 文件名: wechat/render.py
#!/usr/bin/env python3
# -*- coding: UTF-8 -*-

import os
from collections import Counter
from functools import lru_cache
import glob
from pyquery import PyQuery
import logging
logger = logging.getLogger(__name__)

LIB_PATH = os.path.dirname(os.path.abspath(__file__))
STATIC_PATH = os.path.join(LIB_PATH, 'static')
HTML_FILE = os.path.join(STATIC_PATH, 'TP_INDEX.html')
TIME_HTML_FILE = os.path.join(STATIC_PATH, 'TP_TIME.html')
FRIEND_AVATAR_CSS_FILE = os.path.join(STATIC_PATH, 'avatar.css.tpl')

try:
    from csscompressor import compress as css_compress
except ImportError:
    css_compress = lambda x: x

from .msg import *
from .common.textutil import get_file_b64
from .common.progress import ProgressReporter
from .common.timer import timing
from .smiley import SmileyProvider
from .msgslice import MessageSlicerByTime, MessageSlicerBySize

TEMPLATES_FILES = {TYPE_MSG: "TP_MSG",
                   TYPE_IMG: "TP_IMG",
                   TYPE_SPEAK: "TP_SPEAK",
                   TYPE_EMOJI: "TP_EMOJI",
                   TYPE_CUSTOM_EMOJI: "TP_EMOJI",
                   TYPE_LINK: "TP_MSG",
                   TYPE_VIDEO_FILE: "TP_VIDEO_FILE",
                   TYPE_QQMUSIC: "TP_QQMUSIC",
                  }


@lru_cache()
def get_template(name: str | int) -> str | None:
    """Return the html template given a file name or msg type."""
    if isinstance(name, int):
        name = TEMPLATES_FILES.get(name, None)
        if name is None:
            return None
    html_path = os.path.join(STATIC_PATH, f"{name}.html")
    with open(html_path) as f:
        return f.read()


class HTMLRender(object):
    def __init__(self, parser, res=None):
        with open(HTML_FILE) as f:
            self.html = f.read()
        with open(TIME_HTML_FILE) as f:
            self.time_html = f.read()
        self.parser = parser
        self.res = res
        assert self.res is not None, \
            "Resource Directory not given. Cannot render HTML."
        self.smiley = SmileyProvider()

        css_files = glob.glob(os.path.join(LIB_PATH, 'static/*.css'))
        self.css_string = []    # css to add
        for css in css_files:
            logger.info("Loading {}".format(os.path.basename(css)))
            with open(css) as f:
                self.css_string.append(f.read())

        js_files = glob.glob(os.path.join(LIB_PATH, 'static/*.js'))
        # to load jquery before other js
        js_files = sorted(js_files, key=lambda f: 'jquery-latest' in f, reverse=True)
        self.js_string = []
        for js in js_files:
            logger.info("Loading {}".format(os.path.basename(js)))
            with open(js) as f:
                self.js_string.append(f.read())

        self.unknown_type_cnt = Counter()

    @property
    def all_css(self):
        # call after processing all messages,
        # because smiley css need to be included only when necessary
        def process(css):
            css = css_compress(css)
            return u'<style type="text/css">{}</style>'.format(css)

        if hasattr(self, 'final_css'):
            return self.final_css + process(self.smiley.gen_used_smiley_css())

        self.final_css = u"\n".join(map(process, self.css_string))
        return self.final_css + process(self.smiley.gen_used_smiley_css())

    @property
    def all_js(self):
        if hasattr(self, 'final_js'):
            return self.final_js
        def process(js):
            # TODO: add js compress
            return u'<script type="text/javascript">{}</script>'.format(js)
        self.final_js = u"\n".join(map(process, self.js_string))
        return self.final_js

    #@timing(total=True)
    def render_msg(self, msg: WeChatMsg):
        """ render a message, return the html block"""
        # TODO for chatroom, add nickname on avatar
        sender = u'you ' + msg.talker if not msg.isSend else 'me'
        format_dict = {'sender_label': sender,
                       'time': msg.createTime }
        if not msg.known_type:
            self.unknown_type_cnt[msg.type] += 1
        if(not msg.isSend and msg.is_chatroom()):
            format_dict['nickname'] = '>\n       <pre align=\'left\'>'+msg.talker_nickname+'</pre'
        else:
            format_dict['nickname'] = ' '

        def fallback():
            template = get_template(TYPE_MSG)
            content = msg.msg_str()
            content = self.smiley.replace_smileycode(content)
            if not msg.known_type:
                # Show raw (usually xml) content if unknown.
                content = html.escape(content)
            return template.format(content=content, **format_dict)

        template = get_template(msg.type)
        if msg.type == TYPE_SPEAK:
            audio_str, duration = self.res.get_voice_mp3(msg.imgPath)
            format_dict['voice_duration'] = duration
            format_dict['voice_str'] = audio_str
            return template.format(**format_dict)
        elif msg.type == TYPE_IMG:
            # imgPath was original THUMBNAIL_DIRPATH://th_xxxxxxxxx
            imgpath = msg.imgPath.split('_')[-1]
            if not imgpath:
                logger.warn('No imgpath in an image message. Perhaps a bug in wechat.')
                return fallback()
            bigimgpath = self.parser.imginfo.get(msg.msgSvrId)
            fnames = [k for k in [imgpath, bigimgpath] if k]
            img = self.res.get_img(fnames)
            if not img:
                logger.warn("No image thumbnail found for {}".format(imgpath))
                return fallback()
            # TODO do not show fancybox when no bigimg found
            format_dict['img'] = (img, 'jpeg')
            return template.format(**format_dict)
        elif msg.type == TYPE_QQMUSIC:
            jobj = json.loads(msg.msg_str())
            content = f"{jobj['title']} - {jobj['singer']}"

            if msg.imgPath is not None:
                # imgPath was original THUMBNAIL_DIRPATH://th_xxxxxxxxx
                imgpath = msg.imgPath.split('_')[-1]
                img = self.res.get_img([imgpath])
                format_dict['img'] = (img, 'jpeg')
            else:
                template = get_template("TP_QQMUSIC_NOIMG")
            return template.format(url=jobj['url'], content=content, **format_dict)
        elif msg.type == TYPE_EMOJI or msg.type == TYPE_CUSTOM_EMOJI:
            if 'emoticonmd5' in msg.content:
                pq = PyQuery(msg.content)
                md5 = pq('emoticonmd5').text()
            else:
                md5 = msg.imgPath
                # TODO md5 could exist in both.
                # first is emoji md5, second is image2/ md5
                # can use fallback here.
            if md5:
                emoji_img, format = self.res.get_emoji_by_md5(md5)
                format_dict['emoji_format'] = format
                format_dict['emoji_img'] = emoji_img
            else:
                import IPython as IP; IP.embed()
            return template.format(**format_dict)
        elif msg.type == TYPE_LINK:
            pq = PyQuery(msg.content_xml_ready)
            url = pq('url').text()
            if url:
                try:
                    title = pq('title')[0].text
                except Exception as e:
                    logger.warning('No title found in LINK message: ' + str(e))
                    title = url
                content = '<a target="_blank" href="{0}">{1}</a>'.format(url, title)
                format_dict['content'] = content
                return template.format(**format_dict)
        elif msg.type == TYPE_VIDEO_FILE:
            video = self.res.get_video(msg.imgPath)
            if video is None:
                logger.warning(f"Cannot find video {msg.imgPath} ({msg.createTime})")
                # fallback
                format_dict['content'] = f"VIDEO FILE {msg.imgPath}"
                return get_template(TYPE_MSG).format(**format_dict)
            elif video.endswith(".mp4"):
                video_str = get_file_b64(video)
                format_dict["video_str"] = video_str
                return template.format(**format_dict)
            elif video.endswith(".jpg"):
                # only has thumbnail
                image_str = get_file_b64(video)
                format_dict["img"] = (image_str, 'jpeg')
                return get_template(TYPE_IMG).format(**format_dict)
        elif msg.type == TYPE_WX_VIDEO:
            # TODO: fetch video from resource
            return fallback()
        return fallback()

    def _render_partial_msgs(self, msgs):
        """ return single html"""
        self.smiley.reset()
        slicer = MessageSlicerByTime()
        slices = slicer.slice(msgs)

        blocks = []
        for idx, slice in enumerate(slices):
            nowtime = slice[0].createTime
            if idx == 0 or \
               slices[idx - 1][0].createTime.date() != nowtime.date():
                timestr = nowtime.strftime("%m/%d %H:%M:%S")
            else:
                timestr = nowtime.strftime("%H:%M:%S")
            blocks.append(self.time_html.format(time=timestr))
            blocks.extend([self.render_msg(m) for m in slice])
            self.prgs.trigger(len(slice))

        # string operation is extremely slow
        return self.html.format(extra_css=self.all_css,
                            extra_js=self.all_js,
                            chat=msgs[0].chat_nickname,
                            messages=u''.join(blocks)
                           )

    def prepare_avatar_css(self, talkers):
        with open(FRIEND_AVATAR_CSS_FILE) as f:
            avatar_tpl = f.read()
        my_avatar = self.res.get_avatar(self.parser.username)
        css = avatar_tpl.format(name='me', avatar=my_avatar)

        for talker in talkers:
            avatar = self.res.get_avatar(talker)
            css += avatar_tpl.format(name=talker, avatar=avatar)
        self.css_string.append(css)

    def render_msgs(self, msgs):
        """ render msgs of one chat, return a list of html"""
        if msgs[0].is_chatroom():
            talkers = set([m.talker for m in msgs])
        else:
            talkers = set([msgs[0].talker])
        self.prepare_avatar_css(talkers)

        self.res.cache_voice_mp3(msgs)

        chat = msgs[0].chat_nickname
        logger.info(u"Rendering {} messages of {}".format(
            len(msgs), chat))

        self.prgs = ProgressReporter("Render", total=len(msgs))
        slice_by_size = MessageSlicerBySize().slice(msgs)
        ret = [self._render_partial_msgs(s) for s in slice_by_size]
        self.prgs.finish()
        logger.warning("[HTMLRenderer] Unhandled messages (type->cnt): {}".format(self.unknown_type_cnt))
        return ret

if __name__ == '__main__':
    r = HTMLRender()
    with open('/tmp/a.html', 'w') as f:
        print >> f, r.html.format(style=r.css, talker='talker',
                                     messages='haha')
```
